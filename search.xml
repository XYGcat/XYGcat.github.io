<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaWeb</title>
      <link href="/2023/10/06/JavaWeb/"/>
      <url>/2023/10/06/JavaWeb/</url>
      
        <content type="html"><![CDATA[<h2 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一. 基础知识"></a>一. 基础知识</h2><h5 id="1-服务器软件"><a href="#1-服务器软件" class="headerlink" title="1.服务器软件"></a>1.服务器软件</h5><p>Servlet（容器）：可以将动态代码翻译成静态代码的软件。</p><p>Apache和Nginx：只能处理静态代码，需委托Servlet处理动态代码。</p><p>Tomcat：可以处理动态代码，内置了Servlet容器。</p><h5 id="2-HTTP概述"><a href="#2-HTTP概述" class="headerlink" title="2.HTTP概述"></a>2.HTTP概述</h5><p>本质：HTTP定义了游览器与Web服务器之间交换超文本数据的协议。</p><h5 id="3-Tomcat中webapps目录和root目录优先级："><a href="#3-Tomcat中webapps目录和root目录优先级：" class="headerlink" title="3.Tomcat中webapps目录和root目录优先级："></a>3.Tomcat中webapps目录和root目录优先级：</h5><p>webapps目录下的Web项目优先级高于ROOT目录下的Web项目。举例来说，webapps目录下的abc目录，会使ROOT目录下的abc文件或abc目录“隐身”。</p><h2 id="二-Servlet接收GET请求数据"><a href="#二-Servlet接收GET请求数据" class="headerlink" title="二. Servlet接收GET请求数据"></a>二. Servlet接收GET请求数据</h2><h5 id="2-1-WebServlet注解"><a href="#2-1-WebServlet注解" class="headerlink" title="2.1 @WebServlet注解"></a>2.1 @WebServlet注解</h5><p><code>@WebServlet</code> 是 Java Servlet API 的注解，用于标识一个类作为 Servlet 组件。Servlet 是 Java 用于处理 Web 请求的组件，通常用于构建 Web 应用程序。</p><p><code>@WebServlet</code> 注解可以应用于类级别，用于指定 Servlet 的配置信息，包括 URL 映射、初始化参数等。以下是 <code>@WebServlet</code> 注解的常用属性：</p><ul><li><strong>name</strong>：Servlet 的名称。如果不提供，默认为类的完全限定名。</li><li><strong>urlPatterns</strong>：Servlet 映射的 URL 模式。可以指定一个或多个 URL 模式，用于匹配客户端请求的 URL。示例：<code>@WebServlet(urlPatterns = &#123;&quot;/myServlet&quot;, &quot;/servlet&quot;&#125;)</code>。</li><li><strong>value</strong>：与 <code>urlPatterns</code> 属性相同，用于指定 Servlet 映射的 URL 模式。</li><li><strong>initParams</strong>：初始化参数，用于在 Servlet 初始化时传递参数。示例：<code>@WebServlet(initParams = &#123;@WebInitParam(name = &quot;paramName&quot;, value = &quot;paramValue&quot;)&#125;)</code>。</li><li><strong>loadOnStartup</strong>：指示容器在应用启动时是否立即加载此 Servlet。默认值为 -1，表示容器自行决定何时加载。</li></ul><h5 id="2-2-MIME和字符编码"><a href="#2-2-MIME和字符编码" class="headerlink" title="2.2 MIME和字符编码"></a>2.2 MIME和字符编码</h5><p>MIME：描述消息内容类型的因特尔标准，描述了互联网上数据（包括文件）的内容格式。</p><p>语法格式：“type&#x2F;subtype”前面斜杠是类型，斜杠后面是子类型</p><p>可以描述HTTP请求数据的内容格式和HTTP响应数据的内容格式。</p><h5 id="2-3-URL路径"><a href="#2-3-URL路径" class="headerlink" title="2.3 URL路径"></a>2.3 URL路径</h5><p>URL：统一资源定位符，可以唯一标记互联网上的某个资源。</p><p>​URL路径描述了游览器上的网址和Web服务器上物理文件之间的映射关系。</p><p>完整的URL路径语法格式：</p><h6 id=""><a href="#" class="headerlink" title=""></a><img src="/.assets/image-20230927205322261.png" alt="image-20230927205322261"></h6><h5 id="2-4-GET请求数据的构成"><a href="#2-4-GET请求数据的构成" class="headerlink" title="2.4 GET请求数据的构成"></a>2.4 GET请求数据的构成</h5><p><img src="C:\Users\XC\AppData\Roaming\Typora\typora-user-images\image-20230927151722152.png" alt="image-20230927151722152"></p><ol><li><p>请求行</p><p><img src="C:\Users\XC\Desktop\image-20230927151839785.png" alt="image-20230927151839785"></p></li><li><p>请求头列表</p><ul><li><strong>Host</strong><ul><li><strong>含义</strong>: 指定要访问的服务器的主机名和端口号。</li><li><strong>示例</strong>: <code>Host: example.com</code></li></ul></li><li><strong>User-Agent</strong><ul><li><strong>含义</strong>: 标识发起请求的用户代理（通常是浏览器或应用程序）的信息。</li><li><strong>示例</strong>: <code>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/17.17134</code></li></ul></li><li><strong>Accept</strong><ul><li><strong>含义</strong>: 指定客户端可接受的响应内容类型。</li><li><strong>示例</strong>: <code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</code></li></ul></li><li><strong>Accept-Encoding</strong><ul><li><strong>含义</strong>: 指定客户端可接受的内容编码方式，用于传输响应的压缩格式。</li><li><strong>示例</strong>: <code>Accept-Encoding: gzip, deflate</code></li></ul></li><li><strong>Accept-Language</strong><ul><li><strong>含义</strong>: 指定客户端可接受的语言类型。</li><li><strong>示例</strong>: <code>Accept-Language: en-US,en;q=0.9</code></li></ul></li><li><strong>Connection</strong><ul><li><strong>含义</strong>: 控制是否保持持久连接。<code>keep-alive</code> 表示持久连接，<code>close</code> 表示非持久连接。</li><li><strong>示例</strong>: <code>Connection: keep-alive</code></li></ul></li><li><strong>Referer</strong><ul><li><strong>含义</strong>: 包含了当前页面的来源URL，用于指示浏览器是从哪个页面跳转过来的。</li><li><strong>示例</strong>: <code>Referer: https://example.com/page1</code></li></ul></li><li><strong>Cookie</strong><ul><li><strong>含义</strong>: 包含与当前请求相关的HTTP cookie信息。</li><li><strong>示例</strong>: <code>Cookie: name=value; name2=value2</code></li></ul></li></ul><p>这些请求头允许客户端向服务器传递关于请求的信息，包括请求的目标、客户端的特性、以及对响应的期望。</p></li></ol><h5 id="2-5-GET请求数据交互"><a href="#2-5-GET请求数据交互" class="headerlink" title="2.5 GET请求数据交互"></a>2.5 GET请求数据交互</h5><p><img src="https://api2.mubu.com/v3/document_image/1695523471466bc8e.jpg" alt="img"></p><h5 id="2-6-request请求对象获取GET请求数据"><a href="#2-6-request请求对象获取GET请求数据" class="headerlink" title="2.6 request请求对象获取GET请求数据"></a>2.6 request请求对象获取GET请求数据</h5><ol><li><p>获取路径信息</p><ul><li><p>request.getContextPath():返回Web项目的虚拟路径。</p></li><li><p>request.getServletContext().getRealPath(String path):获取在Web应用程序中指定路径的真实文件系统路径的方法。传递一个空字符串时会返回Web项目的根目录。</p><p><code>getRealPath()</code> 方法可以获取相对于部署目录的路径的实际文件系统路径。</p></li></ul></li><li><p>获取GET请求参数信息</p></li><li><p>获取GET请求行信息</p></li><li><p>获取GET请求头信息</p></li><li><p>获取Web服务器主机和游览器主机信息</p></li><li><p>获取URL Mappings信息的方法</p><ul><li>request.getHttpServletMapping()：返回请求的URL Mappings。</li></ul></li></ol><h5 id="2-7-request对象的请求派发功能"><a href="#2-7-request对象的请求派发功能" class="headerlink" title="2.7 request对象的请求派发功能"></a>2.7 request对象的请求派发功能</h5><h6 id="2-7-1-RequestDispatcher"><a href="#2-7-1-RequestDispatcher" class="headerlink" title="2.7.1 RequestDispatcher"></a><strong>2.7.1 RequestDispatcher</strong></h6><p><code>RequestDispatcher</code> 是Servlet API中的一个接口，用于将请求派发到另一个资源，可以是Servlet、JSP页面或其他资源。这样可以将请求传递给其他组件进行处理，实现模块化和组件化的设计。</p><p>可以通过以下两种方式获取<code>RequestDispatcher</code>对象：</p><ul><li><p><strong>通过ServletContext获取</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RequestDispatcher</span> <span class="variable">dispatcher</span> <span class="operator">=</span> getServletContext().getRequestDispatcher(<span class="string">&quot;/path/to/resource&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>通过HttpServletRequest获取</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RequestDispatcher</span> <span class="variable">dispatcher</span> <span class="operator">=</span> request.getRequestDispatcher(<span class="string">&quot;/path/to/resource&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h6 id="2-7-2-请求派发操作"><a href="#2-7-2-请求派发操作" class="headerlink" title="2.7.2 请求派发操作"></a>2.7.2 请求派发操作</h6><p><img src="C:\Users\XC\AppData\Roaming\Typora\typora-user-images\image-20230927154349327.png" alt="img"></p><p>一旦获得了<code>RequestDispatcher</code>对象，可以使用其<code>forward</code>方法将请求派发到指定的资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatcher.forward(request, response);</span><br></pre></td></tr></table></figure><p>或者使用<code>include</code>方法将请求派发到指定资源并将其响应包含在原始响应中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatcher.include(request, response);</span><br></pre></td></tr></table></figure><p><strong>forward方法：</strong></p><p><code>forward</code>方法将请求派发到另一个组件，新的组件接管请求并产生响应。这意味着控制流将移交给新组件，新组件将完全处理请求并生成响应，而原始Servlet不会再参与。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RequestDispatcher</span> <span class="variable">dispatcher</span> <span class="operator">=</span> request.getRequestDispatcher(<span class="string">&quot;/path/to/resource&quot;</span>);</span><br><span class="line">dispatcher.forward(request, response);</span><br></pre></td></tr></table></figure><p><strong>include方法：</strong></p><p><code>include</code>方法将请求派发到另一个组件，但响应将被包含在原始响应中，这意味着原始Servlet会继续处理请求，并将来自新组件的响应内容包含在它自己的响应中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RequestDispatcher</span> <span class="variable">dispatcher</span> <span class="operator">=</span> request.getRequestDispatcher(<span class="string">&quot;/path/to/resource&quot;</span>);</span><br><span class="line">dispatcher.include(request, response);</span><br></pre></td></tr></table></figure><p>适用场景：</p><ul><li><strong>重用功能模块</strong>：可以将一些通用的处理逻辑抽取到一个Servlet中，然后通过请求派发将请求传递给该Servlet处理，实现功能的重用。</li><li><strong>模块化设计</strong>：可以将系统划分为多个模块，每个模块对应一个Servlet，通过请求派发将请求传递给不同的模块处理，实现模块化设计，提高代码可维护性和复用性。</li></ul><p>请求派发功能是Servlet API中非常重要的特性，可以帮助实现更灵活、模块化的Web应用程序设计。</p><h6 id="2-7-3-请求转发之间的数据共享"><a href="#2-7-3-请求转发之间的数据共享" class="headerlink" title="2.7.3 请求转发之间的数据共享"></a>2.7.3 请求转发之间的数据共享</h6><p>数据共享可以通过HttpServletRequest对象的属性进行实现，主要有以下几种方式：</p><ol><li><p><strong>setAttribute和getAttribute方法</strong></p><p>使用<code>setAttribute</code>方法将数据设置到HttpServletRequest对象中，使用<code>getAttribute</code>方法从HttpServletRequest对象中获取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在源Servlet中设置数据</span></span><br><span class="line">request.setAttribute(<span class="string">&quot;dataKey&quot;</span>, <span class="string">&quot;some data&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在目标Servlet中获取数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> (String) request.getAttribute(<span class="string">&quot;dataKey&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Servlet中解绑数据</span></span><br><span class="line">request.removeAttribute(<span class="string">&quot;dataKey&quot;</span>, <span class="string">&quot;some data&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>getParameter方法</strong></p><p>使用<code>getParameter</code>方法可以从HttpServletRequest对象中获取请求参数，这也是一种常见的数据共享方式，特别是对于GET请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取请求参数</span></span><br><span class="line">request.getParameter(<span class="string">&quot;paramKey&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取参数名为“paramKey”的所有参数</span></span><br><span class="line">request.getParameterValue(<span class="string">&quot;paramKey&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>getSession方法</strong></p><p>使用<code>getSession</code>方法可以获取与该请求关联的HttpSession对象，从而实现跨请求的数据共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取HttpSession对象</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个Servlet中设置数据到Session</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;dataKey&quot;</span>, <span class="string">&quot;some data&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个Servlet中获取数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;dataKey&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>ServletContext方法</strong></p><p>使用<code>getServletContext</code>方法可以获取ServletContext对象，从而实现在应用程序范围内的数据共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取ServletContext对象</span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> getServletContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个Servlet中设置数据到ServletContext</span></span><br><span class="line">application.setAttribute(<span class="string">&quot;dataKey&quot;</span>, <span class="string">&quot;some data&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个Servlet中获取数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> (String) application.getAttribute(<span class="string">&quot;dataKey&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p>这些方法可以帮助实现请求转发过程中的数据共享，从而使得不同Servlet之间能够共享数据，方便实现处理逻辑的分离和模块化设计。</p><h2 id="三-Servlet接收POST请求数据"><a href="#三-Servlet接收POST请求数据" class="headerlink" title="三. Servlet接收POST请求数据"></a>三. Servlet接收POST请求数据</h2><h4 id="3-1-FROM表单"><a href="#3-1-FROM表单" class="headerlink" title="3.1 FROM表单"></a>3.1 FROM表单</h4><h5 id="3-1-1-表单标签"><a href="#3-1-1-表单标签" class="headerlink" title="3.1.1 表单标签"></a>3.1.1 表单标签</h5><p>在HTML中，表单（Form）是一种用来收集用户输入的元素，通常用于提交数据到服务器进行处理。表单可以通过<code>&lt;form&gt;</code>标签来定义。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/submit&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/from-data&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 表单内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>action</code> 属性指定表单数据提交的目标URL。</li><li><code>method</code> 属性指定提交数据的HTTP方法，通常为 “get” 或 “post”。</li><li><code>enctype</code>属性设置表单数据的内容格式（MIME）。</li></ul><h5 id="3-1-2-表单控件"><a href="#3-1-2-表单控件" class="headerlink" title="3.1.2 表单控件"></a>3.1.2 表单控件</h5><p>表单中的控件是用来接收用户输入的元素，如文本框、复选框、单选按钮等。以下是一些常见的表单控件示例：</p><ol><li><p><strong>文本框 (Text Input)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;victor&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ID值&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your password&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>value：定义初始值</p><p>id：设置唯一标识符，唯一标记HTML页面上的元素。</p><p>placeholder：为输入框（如文本框、密码框等）提供一个提示性的占位符文本，以指示用户应该在该输入框中输入什么内容。</p></li><li><p><strong>密码框 (Password Input)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your password&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>单选按钮 (Radio Buttons)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">checked</span> /&gt;</span> Male</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span> /&gt;</span> Female</span><br></pre></td></tr></table></figure><p>checked：表示该复选框默认被选中。</p></li><li><p><strong>复选框 (Checkboxes)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sports&quot;</span> <span class="attr">checked</span> /&gt;</span> Sports</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;music&quot;</span> /&gt;</span> Music</span><br></pre></td></tr></table></figure></li><li><p><strong>下拉列表 (Select Dropdown)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;country&quot;</span> <span class="attr">size</span>=<span class="string">&quot;3&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;usa&quot;</span> <span class="attr">selected</span>&gt;</span>USA<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;canada&quot;</span>&gt;</span>Canada<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>size：指定下拉选择框的高度，默认值为1。</p><p>multiple：允许选中多个选项。</p><p>value：指定某个选项的值。</p><p>selected：表示该选项默认被选中。</p></li><li><p><strong>文本域 (Text Area)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;4&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;50&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>cols：定义多行文本框的宽度（单位px）。</p><p>rows：定义多行文本框的高度（单位px）。</p><p>centent：多行文本框默认显示的文字内容。</p></li><li><p><strong>隐藏域 (Hidden Input)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sometokenvalue&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>文件上传框 (File Input)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">name</span>=<span class="string">&quot;myFile&quot;</span> <span class="attr">multiple</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="3-1-3-表单按钮"><a href="#3-1-3-表单按钮" class="headerlink" title="3.1.3 表单按钮"></a>3.1.3 表单按钮</h5><p>表单中的按钮用于提交表单或重置表单的数据。</p><ol><li><p><strong>提交按钮 (Submit Button)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;login&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;login&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>重置按钮 (Reset Button)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">name</span>=<span class="string">&quot;cancel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Reset&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">name</span>=<span class="string">&quot;cancel&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="3-2-POST请求数据的构成"><a href="#3-2-POST请求数据的构成" class="headerlink" title="3.2 POST请求数据的构成"></a>3.2 POST请求数据的构成</h4><h5 id="3-2-1-POST请求行"><a href="#3-2-1-POST请求行" class="headerlink" title="3.2.1 POST请求行"></a>3.2.1 POST请求行</h5><p><img src="C:\Users\XC\AppData\Roaming\Typora\typora-user-images\image-20230927163445537.png" alt="image-20230927163445537"></p><h5 id="3-2-2-POST请求头列表"><a href="#3-2-2-POST请求头列表" class="headerlink" title="3.2.2 POST请求头列表"></a>3.2.2 POST请求头列表</h5><ol><li><strong>Content-Type</strong><ul><li><strong>含义</strong>: 指定请求体的数据格式及字符编码。</li><li><strong>示例</strong>: <code>Content-Type: application/x-www-form-urlencoded</code> 表示数据以 URL 编码形式传递。</li></ul></li><li><strong>Content-Length</strong><ul><li><strong>含义</strong>: 指定请求体的长度，以字节为单位。</li><li><strong>示例</strong>: <code>Content-Length: 123</code></li></ul></li><li><strong>Accept</strong><ul><li><strong>含义</strong>: 指定客户端可接受的响应内容类型。</li><li><strong>示例</strong>: <code>Accept: application/json, text/html</code></li></ul></li><li><strong>Accept-Encoding</strong><ul><li><strong>含义</strong>: 指定客户端可接受的内容编码方式，用于传输响应的压缩格式。</li><li><strong>示例</strong>: <code>Accept-Encoding: gzip, deflate</code></li></ul></li><li><strong>Accept-Language</strong><ul><li><strong>含义</strong>: 指定客户端可接受的语言类型。</li><li><strong>示例</strong>: <code>Accept-Language: en-US,en;q=0.9</code></li></ul></li><li><strong>Referer</strong><ul><li><strong>含义</strong>: 包含了当前页面的来源URL，用于指示浏览器是从哪个页面跳转过来的。</li><li><strong>示例</strong>: <code>Referer: https://example.com/page1</code></li></ul></li><li><strong>Cookie</strong><ul><li><strong>含义</strong>: 包含与当前请求相关的HTTP cookie信息。</li><li><strong>示例</strong>: <code>Cookie: name=value; name2=value2</code></li></ul></li><li><strong>User-Agent</strong><ul><li><strong>含义</strong>: 标识发起请求的用户代理（通常是浏览器或应用程序）的信息。</li><li><strong>示例</strong>: <code>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/17.17134</code></li></ul></li></ol><p>这些请求头允许客户端向服务器传递关于请求的信息，包括请求的内容类型、长度、支持的响应格式、语言、来源等。</p><h5 id="3-2-3-POST请求体"><a href="#3-2-3-POST请求体" class="headerlink" title="3.2.3 POST请求体"></a>3.2.3 POST请求体</h5><p>内容格式：</p><ol><li>application&#x2F;x-www-from-urlencoded</li><li>multipart&#x2F;from-data</li></ol><h5 id="3-2-4-POST请求数据交互"><a href="#3-2-4-POST请求数据交互" class="headerlink" title="3.2.4 POST请求数据交互"></a>3.2.4 POST请求数据交互</h5><p><img src="C:\Users\XC\AppData\Roaming\Typora\typora-user-images\image-20230927163849248.png" alt="image-20230927163849248"></p><h5 id="3-2-5-POST请求转发"><a href="#3-2-5-POST请求转发" class="headerlink" title="3.2.5 POST请求转发"></a>3.2.5 POST请求转发</h5><p><img src="C:\Users\XC\AppData\Roaming\Typora\typora-user-images\image-20230927164102010.png" alt="image-20230927164102010"></p><h5 id="3-2-6-request请求对象获取multipart-from-data请求体中的片段"><a href="#3-2-6-request请求对象获取multipart-from-data请求体中的片段" class="headerlink" title="3.2.6 request请求对象获取multipart&#x2F;from-data请求体中的片段"></a>3.2.6 request请求对象获取multipart&#x2F;from-data请求体中的片段</h5><p>对于包含<code>multipart/form-data</code>编码类型的POST请求，常用于文件上传或复杂数据传输，需要特殊处理来解析请求体中的各个片段（parts）。Servlet API提供了<code>Part</code>接口来处理这种情况。</p><p>以下是获取<code>multipart/form-data</code>请求体中的片段的一般步骤：</p><ol><li><strong>获取Part对象</strong>：通过<code>HttpServletRequest</code>的<code>getPart(String name)</code>方法或<code>getParts()</code>方法来获取<code>Part</code>对象或<code>Collection&lt;Part&gt;</code>对象。</li><li><strong>处理Part对象</strong>：通过<code>Part</code>对象提供的方法来获取请求体的内容。</li></ol><p>下面是一个简单的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.annotation.MultipartConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.MultipartConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Part;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/upload&quot;)</span></span><br><span class="line"><span class="meta">@MultipartConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取所有的Part</span></span><br><span class="line">        Collection&lt;Part&gt; parts = request.getParts();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历处理每个Part</span></span><br><span class="line">        <span class="keyword">for</span> (Part part : parts) &#123;</span><br><span class="line">            <span class="comment">// 获取Part的名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> part.getName();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取输入流，读取Part中的内容</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> part.getInputStream();</span><br><span class="line">            <span class="comment">// 在这里可以对inputStream进行处理</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> getFileName(part);</span><br><span class="line">            <span class="comment">// 在这里可以对fileName进行处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理完后，可以进行相应的响应</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getFileName</span><span class="params">(Part part)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String content : part.getHeader(<span class="string">&quot;content-disposition&quot;</span>).split(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (content.trim().startsWith(<span class="string">&quot;filename&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> content.substring(content.indexOf(<span class="string">&#x27;=&#x27;</span>) + <span class="number">1</span>).trim().replace(<span class="string">&quot;\&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用<code>getParts()</code>方法获取所有的<code>Part</code>对象，然后遍历每个<code>Part</code>对象来获取对应的输入流和文件名。其中，<code>getFileName</code>方法用于从<code>Part</code>的头信息中提取文件名。您可以根据实际需求对获取到的<code>InputStream</code>和文件名进行处理。</p><h2 id="四-Servlet生成HTTP响应数据"><a href="#四-Servlet生成HTTP响应数据" class="headerlink" title="四. Servlet生成HTTP响应数据"></a>四. Servlet生成HTTP响应数据</h2><h3 id="4-1-HTTP响应数据的构成"><a href="#4-1-HTTP响应数据的构成" class="headerlink" title="4.1 HTTP响应数据的构成"></a>4.1 HTTP响应数据的构成</h3><ol><li>响应行<ul><li>HTTP版本</li><li>响应状态码</li><li>状态码对应的简要描述</li></ul></li><li>响应头列表</li><li>空行</li><li>响应体</li></ol><h3 id="4-2-重定向、定时刷新和请求转发的实现及比较"><a href="#4-2-重定向、定时刷新和请求转发的实现及比较" class="headerlink" title="4.2 重定向、定时刷新和请求转发的实现及比较"></a>4.2 重定向、定时刷新和请求转发的实现及比较</h3><p>重定向、定时刷新、请求转发和请求包含是Web开发中常用的页面跳转和数据共享技术，它们各自有不同的实现方式和适用场景。它们的实现和比较如下：</p><h5 id="4-2-1-重定向"><a href="#4-2-1-重定向" class="headerlink" title="4.2.1 重定向"></a>4.2.1 重定向</h5><p>重定向是一种服务器端的跳转方式，它告诉浏览器要跳转到一个新的URL。浏览器接收到重定向响应后会发起新的HTTP请求，从而加载新的页面。</p><p><strong>实现方式（Java Servlet）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;newPage.jsp&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>完全刷新页面，URL会变更，可以避免表单重复提交。</li><li>能够跳转到外部URL。</li></ul><p><strong>缺点：</strong></p><ul><li>需要多次HTTP请求，效率较低。</li></ul><h5 id="4-2-2-定时刷新"><a href="#4-2-2-定时刷新" class="headerlink" title="4.2.2 定时刷新"></a>4.2.2 定时刷新</h5><p>定时刷新是在HTML中通过<code>&lt;meta&gt;</code>标签设置页面自动刷新的时间间隔，可以实现定时跳转或刷新。</p><p><strong>实现方式（HTML）：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;5;url=newPage.jsp&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>可以自动刷新页面，类似定时任务的效果。</li></ul><p><strong>缺点：</strong></p><ul><li>用户无法取消刷新，可能会打断用户的操作。</li><li>不能实现后台逻辑的处理。</li></ul><h5 id="4-2-3-请求转发"><a href="#4-2-3-请求转发" class="headerlink" title="4.2.3 请求转发"></a>4.2.3 请求转发</h5><p>请求转发是在服务器内部完成的，请求转发不会改变URL，是服务器端的跳转方式。</p><p><strong>实现方式（Java Servlet）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RequestDispatcher</span> <span class="variable">dispatcher</span> <span class="operator">=</span> request.getRequestDispatcher(<span class="string">&quot;newPage.jsp&quot;</span>);</span><br><span class="line">dispatcher.forward(request, response);</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>内部操作，效率较高。</li><li>可以共享request域中的数据。</li><li>用户感知不到服务器内部的跳转。</li></ul><p><strong>缺点：</strong></p><ul><li>只能跳转到当前Web应用程序内的资源。</li></ul><h5 id="4-2-4-请求包含"><a href="#4-2-4-请求包含" class="headerlink" title="4.2.4 请求包含"></a>4.2.4 请求包含</h5><p><strong>实现方式（Java Servlet）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RequestDispatcher</span> <span class="variable">dispatcher</span> <span class="operator">=</span> request.getRequestDispatcher(<span class="string">&quot;includedServlet&quot;</span>);</span><br><span class="line">dispatcher.include(request, response);</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>可以模块化设计，共享代码和数据。</li><li>可以共享request域中的数据。</li></ul><p><strong>缺点：</strong></p><ul><li>无法跳转到外部URL。</li><li>被包含的Servlet不能改变响应头。</li></ul><h6 id="比较"><a href="#比较" class="headerlink" title="比较"></a><strong>比较</strong></h6><ul><li><strong>适用场景</strong>：<ul><li>重定向适用于跳转到外部URL或新的页面，避免表单重复提交等情况。</li><li>定时刷新适用于自动刷新页面，类似于实时信息更新的场景。</li><li>请求转发适用于服务器内部资源的跳转，保持URL不变，且可以共享request域的数据。</li><li>请求包含适用于模块化设计，共享代码和数据，内部跳转。</li></ul></li><li><strong>效率</strong>：<ul><li>请求转发效率高，不需要多次HTTP请求。</li><li>重定向效率相对较低，需要两次HTTP请求。</li><li>定时刷新效率相对较低，需要多次HTTP请求。</li><li>请求包含效率较高，不需要额外的HTTP请求。</li></ul></li><li><strong>URL变化</strong>：<ul><li>重定向会改变URL。</li><li>请求转发、定时刷新和请求包含不改变URL。</li></ul></li><li><strong>数据共享</strong>：<ul><li>请求转发和请求包含可以共享request域中的数据。</li><li>重定向和定时刷新不能直接共享数据，可以通过Session或URL参数传递。</li></ul></li></ul><h3 id="4-3-使用response生成HTTP响应体"><a href="#4-3-使用response生成HTTP响应体" class="headerlink" title="4.3 使用response生成HTTP响应体"></a>4.3 使用response生成HTTP响应体</h3><h4 id="4-3-1-response响应对象的缓存"><a href="#4-3-1-response响应对象的缓存" class="headerlink" title="4.3.1 response响应对象的缓存"></a>4.3.1 response响应对象的缓存</h4><h4 id="4-3-2-向response缓存添加数据"><a href="#4-3-2-向response缓存添加数据" class="headerlink" title="4.3.2 向response缓存添加数据"></a>4.3.2 向response缓存添加数据</h4><ol><li>文本型数据<ul><li>respons.getWaiter().waiter()：只能添加字符串</li><li>​                                   .print()：各类型转为字符串添加</li><li>​                                   .println()：加了回车符和换行符</li><li>​                                   .append()：支持方法连缀</li></ul></li><li>字节数据<ul><li>respons.getOutputStream().waiter()</li></ul></li></ol><h2 id="五-异步请求和异步响应"><a href="#五-异步请求和异步响应" class="headerlink" title="五. 异步请求和异步响应"></a>五. 异步请求和异步响应</h2><h3 id="5-1-前端三级套"><a href="#5-1-前端三级套" class="headerlink" title="5.1 前端三级套"></a>5.1 前端三级套</h3><h4 id="5-1-1-HTML"><a href="#5-1-1-HTML" class="headerlink" title="5.1.1 HTML"></a>5.1.1 HTML</h4><p><code>onload</code>：<body>标签常用的事件属性。表示HTML页面加载时触发onload。</p><p><code>onblur</code>：单行文本框<input>标签常用的事件属性。当文本框失去焦点时触发onblur。</p><p><code>onchange</code>：当内容改变且失去焦点时触发onchange。</p><p><code>onclick</code>：当HTML元素上发生单击事件时触发onclick。</p><p><code>ondbclick</code>：当HTML元素上发生双击事件时触发ondbclick。</p><h4 id="5-1-2-CSS"><a href="#5-1-2-CSS" class="headerlink" title="5.1.2 CSS"></a>5.1.2 CSS</h4><p>标签选择器：<code>p&#123;&#125;</code></p><p>类选择器：<code>.redColor&#123;&#125;</code></p><p>ID选择器：<code>#line&#123;&#125;</code></p><h4 id="5-1-3-JavaScript"><a href="#5-1-3-JavaScript" class="headerlink" title="5.1.3 JavaScript"></a>5.1.3 JavaScript</h4><p><strong>1.基础知识：</strong></p><p><strong>1.1 变量</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">codevar myVariable = <span class="number">10</span>; <span class="comment">// 声明变量并赋值</span></span><br><span class="line"><span class="keyword">let</span> anotherVariable = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 使用 let 声明变量（ES6）</span></span><br><span class="line"><span class="keyword">const</span> constantValue = <span class="number">3.14</span>; <span class="comment">// 使用 const 声明常量</span></span><br></pre></td></tr></table></figure><p><strong>1.2 数据类型</strong></p><p>JavaScript 包含多种数据类型，如数字、字符串、布尔值、数组、对象等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">42</span>; <span class="comment">// 数字</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> isTrue = <span class="literal">true</span>; <span class="comment">// 布尔值</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;; <span class="comment">// 对象</span></span><br></pre></td></tr></table></figure><p><strong>1.3 运算符</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="number">10</span> + <span class="number">5</span>; <span class="comment">// 加法</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="number">10</span> - <span class="number">5</span>; <span class="comment">// 减法</span></span><br><span class="line"><span class="keyword">let</span> product = <span class="number">10</span> * <span class="number">5</span>; <span class="comment">// 乘法</span></span><br><span class="line"><span class="keyword">let</span> quotient = <span class="number">10</span> / <span class="number">5</span>; <span class="comment">// 除法</span></span><br><span class="line"><span class="keyword">let</span> remainder = <span class="number">10</span> % <span class="number">3</span>; <span class="comment">// 取余</span></span><br></pre></td></tr></table></figure><p><strong>2. 控制流结构</strong></p><p><strong>2.1 条件语句</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="comment">// 如果条件为真执行这里的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 如果条件为假执行这里的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.2 循环</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure><p><strong>3. 函数</strong></p><p>函数是 JavaScript 中的重要概念，它可以重用代码块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> message = <span class="title function_">greet</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// 输出: &quot;Hello, Alice!&quot;</span></span><br></pre></td></tr></table></figure><p><strong>4. DOM 操作</strong></p><p>DOM（Document Object Model）允许 JavaScript 操作网页中的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myElementId&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改元素内容</span></span><br><span class="line">element.<span class="property">innerHTML</span> = <span class="string">&quot;New content&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加事件监听器</span></span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Element clicked!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>5. 事件处理</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 中：</span></span><br><span class="line"><span class="comment">// &lt;button onclick=&quot;handleButtonClick()&quot;&gt;Click me&lt;/button&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleButtonClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Button clicked!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-异步请求和异步响应"><a href="#5-2-异步请求和异步响应" class="headerlink" title="5.2 异步请求和异步响应"></a>5.2 异步请求和异步响应</h3><p>异步请求：允许多个请求同时发出，在执行下一个操作之前，不需要等待上一个操作返回的执行结果。</p><p>AJAX：在不重新加载当前页面的前提下，实现HTML页面的局部刷新。（异步的JS技术）</p><h4 id="5-2-1-XMLHttpRequest异步请求对象"><a href="#5-2-1-XMLHttpRequest异步请求对象" class="headerlink" title="5.2.1 XMLHttpRequest异步请求对象"></a>5.2.1 XMLHttpRequest异步请求对象</h4><p>（实现AJAX技术的核心）</p><ol><li><p>XMLHttpRequest异步请求对象的辅助函数</p><ul><li>request.setRequestHeader(head:String,value:String)：设置异步请求的请求头。</li><li>request.getAllRequestHeaders(head:String,value:String)：返回异步响应的响应头列表。</li><li>request.getRequestHeader(head:String)：返回异步响应中指定响应头的响应头值。</li></ul></li><li><p>XMLHttpRequest异步请求对象的核心函数</p><ul><li><code>request.open(method, url, async);</code><ul><li>用于初始化一个请求，指定请求的类型、URL以及是否异步执行。</li><li><code>method</code>: 请求的HTTP方法，如 “GET”、”POST” 等。</li><li><code>url</code>: 请求的URL。</li><li><code>async</code>: 是否异步执行请求，一般为 <code>true</code>。</li></ul></li><li><code>request.send(data);</code><ul><li>用于发送请求，发起实际的HTTP请求。</li><li><code>data</code>: 要作为请求主体发送的数据，通常用于POST请求。</li></ul></li></ul></li><li><p>FromData对象</p><ul><li>用于创建一个表单数据对象，可以用于将数据编译成键&#x2F;值对，主要用于发送表单数据。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;john_doe&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将FormData对象作为send()方法的参数发送请求</span></span><br><span class="line">request.<span class="title function_">send</span>(formData);</span><br></pre></td></tr></table></figure></li><li><p>XMLHttpRequest异步请求对象的核心属性</p><ul><li>request.readyState：表示当前异步请求的状态。5种：<ul><li>1.<code>UNSENT</code> (0)<ul><li><strong>描述</strong>: 初始状态，XMLHttpRequest对象已经创建，但尚未调用<code>open()</code>方法。</li></ul></li><li>2.<code>OPENED</code> (1)<ul><li><strong>描述</strong>: 已调用<code>open()</code>方法，但尚未调用<code>send()</code>方法。</li></ul></li><li>3.<code>HEADERS_RECEIVED</code> (2)<ul><li><strong>描述</strong>: 已调用<code>send()</code>方法，已经接收到响应头信息（HTTP头部）。</li></ul></li><li>4.<code>LOADING</code> (3)<ul><li><strong>描述</strong>: 接收到响应头信息，正在接收响应体（响应数据）。</li></ul></li><li>5.<code>DONE</code> (4)<ul><li><strong>描述</strong>: 响应数据接收完成，可以访问响应数据了。</li></ul></li></ul></li><li>request.responseType：设置响应数据的数据类型。</li><li>request.responseText：获取响应的文本型数据。</li><li>request.status：获取响应状态码。</li></ul></li><li><p>XMLHttpRequest异步请求对象的事件监听</p></li></ol><h2 id="六-Cookie与Session"><a href="#六-Cookie与Session" class="headerlink" title="六. Cookie与Session"></a>六. Cookie与Session</h2><h3 id="6-1-Cookie会话控制技术"><a href="#6-1-Cookie会话控制技术" class="headerlink" title="6.1 Cookie会话控制技术"></a>6.1 Cookie会话控制技术</h3><p>Cookie是一种在客户端存储的小型文本文件，用于在客户端和服务器之间传递数据。它通常用于会话控制、用户跟踪和存储用户偏好等。</p><h4 id="6-1-1-工作原理"><a href="#6-1-1-工作原理" class="headerlink" title="6.1.1 工作原理"></a>6.1.1 工作原理</h4><ul><li><strong>创建Cookie</strong>： 当服务器接收到一个HTTP请求时，它可以在HTTP响应头中添加一个<code>Set-Cookie</code>标头来创建Cookie。这个标头包含了Cookie的名称、值以及一些可选的属性（如过期时间、域、路径等）。</li><li><strong>发送Cookie到客户端</strong>： 服务器通过HTTP响应将Cookie发送给客户端。这会将Cookie存储在客户端的浏览器中。Cookie会与特定的域名相关联，只有与该域名相关的HTTP请求才会携带相应的Cookie。</li><li><strong>存储在客户端</strong>： 客户端的浏览器会将收到的Cookie存储在本地。每个Cookie都与特定的域名相关联，浏览器会根据域名和路径来确定何时发送Cookie。</li><li><strong>发送Cookie到服务器</strong>： 在客户端向服务器发起HTTP请求时，浏览器会将与该域名相关联的所有Cookie附加到请求头中，并通过<code>Cookie</code>标头将它们发送给服务器。</li><li><strong>服务器读取Cookie</strong>： 服务器可以通过HTTP请求头中的<code>Cookie</code>标头来读取与该域名相关的所有Cookie。服务器可以解析Cookie，并根据其中的数据来做相应的处理。</li><li><strong>使用Cookie数据</strong>： 服务器可以使用Cookie中的数据来实现用户跟踪、用户身份验证、个性化内容等功能。服务器可以根据Cookie中的信息来适应用户的请求，提供个性化的体验。</li></ul><h4 id="6-1-2-本质和核心"><a href="#6-1-2-本质和核心" class="headerlink" title="6.1.2 本质和核心"></a>6.1.2 本质和核心</h4><ul><li><strong>本质</strong>：Cookie是由服务器发送到客户端并存储在客户端的一小段文本信息。每个Cookie都与特定的域关联。</li><li><strong>核心</strong>：使用游览器端技术，实现Cookie会话期间，多次响应&#x2F;请求之间的数据共享。</li></ul><h4 id="6-1-3-创建Cookie"><a href="#6-1-3-创建Cookie" class="headerlink" title="6.1.3 创建Cookie"></a>6.1.3 创建Cookie</h4><p>在Java程序中创建Cookie可以通过使用<code>javax.servlet.http.Cookie</code>类来实现。以下是创建Cookie的步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Cookie对象</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;cookieName&quot;</span>, <span class="string">&quot;cookieValue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Cookie的属性</span></span><br><span class="line">cookie.setMaxAge(<span class="number">3600</span>); <span class="comment">// 设置Cookie的生命周期，以秒为单位，这里设置为1小时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选：设置Cookie的路径</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/&quot;</span>); <span class="comment">// 设置Cookie的路径为根路径，使得整个应用都可以访问这个Cookie</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选：设置Cookie的域名限制</span></span><br><span class="line">cookie.setDomain(<span class="string">&quot;.example.com&quot;</span>); <span class="comment">// 设置Cookie的域名限制为.example.com，只有符合该域名的页面才能访问该Cookie</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选：设置Cookie为安全Cookie</span></span><br><span class="line">cookie.setSecure(<span class="literal">true</span>); <span class="comment">// 设置Cookie为安全Cookie，只能在HTTPS连接中传输</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选：设置Cookie为HttpOnly</span></span><br><span class="line">cookie.setHttpOnly(<span class="literal">true</span>); <span class="comment">// 设置Cookie为HttpOnly，禁止JavaScript通过document.cookie来访问Cookie</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Cookie添加到HTTP响应</span></span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><h4 id="6-1-4-读取Cookie"><a href="#6-1-4-读取Cookie" class="headerlink" title="6.1.4 读取Cookie"></a>6.1.4 读取Cookie</h4><p>要读取Cookie，可以通过HttpServletRequest对象的<code>getCookies()</code>方法获取Cookie数组，然后遍历数组获取Cookie的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">if</span> (cookies != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cookie.getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cookie.getValue();</span><br><span class="line">        <span class="comment">// 进行相应的操作，如输出Cookie信息或处理Cookie值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-5-重定向和请求转发关于Cookie使用的区别"><a href="#6-1-5-重定向和请求转发关于Cookie使用的区别" class="headerlink" title="6.1.5 重定向和请求转发关于Cookie使用的区别"></a>6.1.5 重定向和请求转发关于Cookie使用的区别</h4><ul><li>请求转发：在请求转发过程中，客户端发出的请求并不会改变，而是服务器将请求转发到另一个资源上。在转发过程中，客户端和服务器之间的连接不会断开，因此可以保持之前的会话状态。</li><li>重定向：在重定向过程中，客户端发出的请求会被重新指向一个新的URL地址。在重定向过程中，客户端和服务器之间的连接会断开，因此无法保持之前的会话状态。</li></ul><h3 id="6-2-Session会话控制技术"><a href="#6-2-Session会话控制技术" class="headerlink" title="6.2 Session会话控制技术"></a>6.2 Session会话控制技术</h3><h4 id="6-2-1-工作原理"><a href="#6-2-1-工作原理" class="headerlink" title="6.2.1 工作原理"></a>6.2.1 工作原理</h4><ul><li><strong>会话的创建</strong>：<ul><li>当用户第一次访问一个Web应用时，服务器会为该用户创建一个<code>Session</code>对象。</li></ul></li><li><strong>Session ID</strong>：<ul><li>服务器会为每个<code>Session</code>分配一个唯一的标识符，通常称为<code>Session ID</code>。这个ID会通过Cookie或URL重写的方式发送给客户端。</li></ul></li><li><strong>客户端请求</strong>：<ul><li>客户端在后续请求中通过Cookie或URL重写将<code>Session ID</code>发送给服务器，以标识该用户的会话。</li></ul></li><li><strong>会话数据存储</strong>：<ul><li>服务器会将每个<code>Session</code>对象与其对应的<code>Session ID</code>关联起来，并将该<code>Session</code>对象存储在服务器端，一般存储在内存或持久化存储中（如数据库、文件系统）。</li></ul></li><li><strong>用户状态存储</strong>：<ul><li>服务器可以向<code>Session</code>对象中存储用户的状态信息，这些信息可以在用户的多次请求间保持不变，实现状态保持。</li></ul></li><li><strong>会话失效</strong>：<ul><li>会话可以在一定时间内保持活跃，超过一定时间或用户关闭浏览器时，会话可能会失效，服务器会将其销毁。</li></ul></li></ul><p><strong>会话管理方式</strong>：</p><ul><li><strong>基于Cookie的会话管理</strong>：<ul><li>通过在客户端存储<code>Session ID</code>的Cookie实现。客户端每次请求时会自动将<code>Session ID</code>发送给服务器。</li></ul></li><li><strong>基于URL重写的会话管理</strong>：<ul><li>将<code>Session ID</code>添加到URL中，每次请求时通过URL发送<code>Session ID</code>。不依赖Cookie。</li></ul></li><li><strong>HTTPSession对象</strong>：<ul><li>在Java Web开发中，使用<code>HttpSession</code>对象来实现会话管理，该对象由Servlet容器提供。</li></ul></li></ul><h4 id="6-2-2-本质与核心"><a href="#6-2-2-本质与核心" class="headerlink" title="6.2.2 本质与核心"></a>6.2.2 本质与核心</h4><ul><li><p>本质：在服务器端维护一种数据结构，用于存储特定用户或客户端的信息和状态。</p></li><li><p>核心：使用Web服务器端技术，实现session会话期间，多次响应&#x2F;请求之间的数据共享</p></li></ul><h4 id="6-2-3-开启和获取Session"><a href="#6-2-3-开启和获取Session" class="headerlink" title="6.2.3 开启和获取Session"></a>6.2.3 开启和获取Session</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Servlet中获取HttpServletRequest对象</span></span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启Session</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(); <span class="comment">// 如果会话存在则返回该会话，否则创建一个新的会话</span></span><br></pre></td></tr></table></figure><h4 id="6-2-4-Session对象的使用"><a href="#6-2-4-Session对象的使用" class="headerlink" title="6.2.4 Session对象的使用"></a>6.2.4 Session对象的使用</h4><p>一旦获取了Session对象，可以通过该对象进行数据的存储、读取和删除等操作，以实现对用户状态和信息的管理。</p><p>存储数据到Session</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储数据到Session</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;john_doe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从Session中读取数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除特定属性</span></span><br><span class="line">session.removeAttribute(<span class="string">&quot;username&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="6-2-5-删除Session或使Session失效"><a href="#6-2-5-删除Session或使Session失效" class="headerlink" title="6.2.5 删除Session或使Session失效"></a>6.2.5 删除Session或使Session失效</h4><ol><li>Web服务器定期清理僵尸session</li><li>手动删除</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使Session失效</span></span><br><span class="line">session.invalidate(); <span class="comment">// 会立即失效当前会话，清除会话中的所有属性</span></span><br></pre></td></tr></table></figure><h4 id="6-2-6-Session的综合使用"><a href="#6-2-6-Session的综合使用" class="headerlink" title="6.2.6 Session的综合使用"></a>6.2.6 Session的综合使用</h4><h5 id="1-使用Session避免请求转发的表单重复提交"><a href="#1-使用Session避免请求转发的表单重复提交" class="headerlink" title="1.使用Session避免请求转发的表单重复提交"></a><strong>1.使用Session避免请求转发的表单重复提交</strong></h5><ul><li><strong>用户提交表单时</strong>：<ul><li>在处理表单提交的Servlet中，首先检查Session中是否存在一个特定的标识，表示该表单已经被处理过。如果存在这个标识，表示表单已经提交过，可以阻止重复提交。</li></ul></li><li><strong>用户第一次提交表单时</strong>：<ul><li>在处理表单提交的Servlet中，将一个特定的标识存储到Session中，表示表单已经被处理过。这个标识可以是一个布尔值、一个特定的字符串或其他标识。</li></ul></li></ul><p>以下是具体的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/processForm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormProcessingServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否已经处理过该表单</span></span><br><span class="line">        <span class="keyword">if</span> (session.getAttribute(<span class="string">&quot;formProcessed&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 表示表单已经处理过，重定向到避免重复提交的页面</span></span><br><span class="line">            response.sendRedirect(<span class="string">&quot;formAlreadyProcessed.jsp&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理表单数据</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标记表单已经处理</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;formProcessed&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重定向到处理完成的页面</span></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;formProcessedSuccessfully.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>FormProcessingServlet</code>是处理表单提交的Servlet。它首先检查Session中是否存在名为”formProcessed”的标识，如果存在则重定向到一个提示页面，否则继续处理表单数据并在处理完成后将标识存储到Session中。这样可以确保表单只被处理一次，避免重复提交。</p><p>同时，需要在适当的时候清除Session中的标识，以便用户能够提交新的表单数据，比如在用户完成业务流程后清除该标识。</p><h5 id="2-使用Session实现身份验证"><a href="#2-使用Session实现身份验证" class="headerlink" title="2.使用Session实现身份验证"></a><strong>2.使用Session实现身份验证</strong></h5><ul><li><strong>用户登录</strong>：<ul><li>用户通过提供用户名和密码进行登录。在验证用户凭据的过程中，如果验证成功，则在Session中存储用户的身份信息，表示用户已登录。</li></ul></li><li><strong>身份信息存储到Session</strong>：<ul><li>在用户登录成功后，将相关的身份信息（如用户ID、用户名等）存储到Session中。</li></ul></li><li><strong>访问受保护资源时进行身份验证</strong>：<ul><li>当用户访问受保护资源时，首先检查Session中是否存在用户身份信息。如果存在，表示用户已经登录，可以访问受保护资源；如果不存在，表示用户未登录，需要进行身份验证或跳转到登录页面。</li></ul></li></ul><p>以下是一个基本的Java代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取用户名和密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 假设存在用户管理服务</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 验证用户身份</span></span><br><span class="line">        <span class="keyword">if</span> (userService.authenticate(username, password)) &#123;</span><br><span class="line">            <span class="comment">// 身份验证成功，存储用户身份信息到Session</span></span><br><span class="line">            <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">            session.setAttribute(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">            session.setAttribute(<span class="string">&quot;loggedIn&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 重定向到受保护资源或其他需要登录的页面</span></span><br><span class="line">            response.sendRedirect(<span class="string">&quot;home.jsp&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 身份验证失败，返回登录页面或提示信息</span></span><br><span class="line">            response.sendRedirect(<span class="string">&quot;login.jsp?error=1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，用户登录时会验证其身份信息，如果验证成功，将用户名和登录状态存储到Session中。然后，可以在其他Servlet或页面中检查Session中的登录状态来判断用户是否已登录，以实现身份验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/protectedResource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtectedResourceServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">loggedIn</span> <span class="operator">=</span> (Boolean) session.getAttribute(<span class="string">&quot;loggedIn&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (loggedIn != <span class="literal">null</span> &amp;&amp; loggedIn) &#123;</span><br><span class="line">            <span class="comment">// 用户已登录，允许访问受保护资源</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用户未登录，重定向到登录页面</span></span><br><span class="line">            response.sendRedirect(<span class="string">&quot;login.jsp&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ProtectedResourceServlet</code>中，通过检查Session中的登录状态来决定用户是否可以访问受保护资源。如果用户未登录，则重定向到登录页面。</p><h5 id="3-实现购物车功能"><a href="#3-实现购物车功能" class="headerlink" title="3.实现购物车功能"></a><strong>3.实现购物车功能</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户添加商品到购物车时，存储购物车信息到Session</span></span><br><span class="line">List&lt;Product&gt; cartItems = ...;</span><br><span class="line">session.setAttribute(<span class="string">&quot;cart&quot;</span>, cartItems);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在结账时读取Session中的购物车信息</span></span><br><span class="line">List&lt;Product&gt; cartItems = (List&lt;Product&gt;) session.getAttribute(<span class="string">&quot;cart&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="4-使用Session实现验证码的验证"><a href="#4-使用Session实现验证码的验证" class="headerlink" title="4.使用Session实现验证码的验证"></a>4.使用Session实现验证码的验证</h5><ul><li><strong>生成验证码</strong>：<ul><li>在用户请求验证码时，服务器端生成一个随机验证码，并将其存储在Session中，同时将验证码以图像形式返回给客户端。</li></ul></li><li><strong>显示验证码给用户</strong>：<ul><li>在Web页面上，将生成的验证码图像显示给用户，通常是通过HTML的<code>&lt;img&gt;</code>标签显示。</li></ul></li><li><strong>用户输入验证码</strong>：<ul><li>用户在页面上输入验证码。</li></ul></li><li><strong>验证用户输入</strong>：<ul><li>在提交表单时，服务器端接收用户输入的验证码，然后与Session中存储的验证码进行比对。</li></ul></li></ul><p>以下是一个基本的Java代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/captcha&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaptchaServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 生成随机验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">captcha</span> <span class="operator">=</span> generateRandomCaptcha();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将验证码存储到Session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">&quot;captcha&quot;</span>, captcha);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将验证码图像以响应流的形式返回给客户端</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">        renderCaptchaImage(captcha, response.getOutputStream());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">generateRandomCaptcha</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 生成随机验证码逻辑</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ABCD&quot;</span>;  <span class="comment">// 示例验证码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renderCaptchaImage</span><span class="params">(String captcha, OutputStream outputStream)</span> &#123;</span><br><span class="line">        <span class="comment">// 将验证码渲染为图像逻辑</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>CaptchaServlet</code>用于生成和显示验证码图像。生成的验证码将存储在Session中，以便后续验证。验证码图像通过Servlet以响应流的形式返回给客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/validateCaptcha&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaptchaValidationServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 用户输入的验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userInputCaptcha</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;captcha&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从Session中获取存储的验证码</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="type">String</span> <span class="variable">storedCaptcha</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;captcha&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 验证用户输入的验证码是否正确</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> userInputCaptcha != <span class="literal">null</span> &amp;&amp; userInputCaptcha.equals(storedCaptcha);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isValid) &#123;</span><br><span class="line">            <span class="comment">// 验证通过，处理其他业务逻辑</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            response.sendRedirect(<span class="string">&quot;successPage.jsp&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 验证失败，返回错误信息或重定向到错误页面</span></span><br><span class="line">            response.sendRedirect(<span class="string">&quot;errorPage.jsp&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>CaptchaValidationServlet</code>中，用户提交表单时，会获取用户输入的验证码，并与Session中存储的验证码进行比对。如果验证码验证通过，可以继续处理其他业务逻辑；如果验证失败，可以返回错误信息或重定向到错误页面。</p><h2 id="七-过滤器和监听器"><a href="#七-过滤器和监听器" class="headerlink" title="七. 过滤器和监听器"></a>七. 过滤器和监听器</h2><h3 id="7-1-过滤器"><a href="#7-1-过滤器" class="headerlink" title="7.1 过滤器"></a>7.1 过滤器</h3><p>过滤器（Filter）是JavaEE中的一种组件，用于对Servlet容器的请求和响应进行预处理和后处理。它可以对请求进行修改、过滤或验证，然后将请求传递给目标Servlet，以及对Servlet的响应进行过滤或修改。</p><h4 id="7-1-1-过滤器的特点和作用"><a href="#7-1-1-过滤器的特点和作用" class="headerlink" title="7.1.1 过滤器的特点和作用"></a>7.1.1 过滤器的特点和作用</h4><ul><li><strong>特点</strong>：<ul><li>可以对所有URL模式或特定URL模式的请求进行拦截。</li><li>可以多个过滤器组合起来形成过滤器链。</li><li>可以对请求和响应进行处理，如修改请求参数、验证身份、日志记录等。</li></ul></li><li><strong>作用</strong>：<ul><li>认证和授权：验证用户身份并授予适当的访问权限。</li><li>日志记录：记录请求和响应信息以进行分析或调试。</li><li>数据压缩：对响应数据进行压缩以节省带宽。</li><li>图像或CSS处理：修改请求以提供适当的图像或CSS文件。</li><li>异常处理：捕获并处理异常，以提供更友好的错误页面。</li></ul></li></ul><h4 id="7-1-2-创建一个简单的过滤器示例"><a href="#7-1-2-创建一个简单的过滤器示例" class="headerlink" title="7.1.2 创建一个简单的过滤器示例"></a>7.1.2 创建一个简单的过滤器示例</h4><p>假设我们创建一个简单的过滤器，用于在接收到请求时输出一条日志信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 初始化过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 在请求到达目标Servlet之前进行处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;LoggingFilter: Request received.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续将请求传递给下一个过滤器或目标Servlet</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在响应返回客户端之前进行处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;LoggingFilter: Response sent.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 销毁过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们实现了<code>Filter</code>接口并实现了<code>doFilter</code>方法，其中在请求到达目标Servlet之前输出日志信息，在响应返回客户端之前输出另一条日志信息。</p><p><strong>配置过滤器：</strong></p><p>在<code>web.xml</code>文件中配置过滤器和过滤器映射。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>LoggingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.example.LoggingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置过滤器映射 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>LoggingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!-- 拦截所有URL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 其他Servlet、Listener等的配置 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述配置中，我们将过滤器<code>LoggingFilter</code>配置为拦截所有URL模式，并在<code>web.xml</code>中进行了相应的映射。</p><p>现在，每次有请求进入应用程序时，都会通过我们创建的过滤器，输出日志信息。</p><h4 id="7-1-3-综合应用"><a href="#7-1-3-综合应用" class="headerlink" title="7.1.3 综合应用"></a>7.1.3 综合应用</h4><h5 id="1-URL级别的权限访问控制"><a href="#1-URL级别的权限访问控制" class="headerlink" title="1.URL级别的权限访问控制"></a>1.URL级别的权限访问控制</h5><p>首先，我们创建一个简单的用户类模拟用户权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; roles;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor, getters, setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们创建一个模拟的用户管理类，用于检查用户的权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, User&gt; userDatabase = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// Simulated user data</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">adminUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;admin&quot;</span>, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;USER&quot;</span>)));</span><br><span class="line">        <span class="type">User</span> <span class="variable">normalUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;user&quot;</span>, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Collections.singletonList(<span class="string">&quot;USER&quot;</span>)));</span><br><span class="line">        </span><br><span class="line">        userDatabase.put(adminUser.getUsername(), adminUser);</span><br><span class="line">        userDatabase.put(normalUser.getUsername(), normalUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">getUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDatabase.get(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们创建一个过滤器来进行权限访问控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 初始化过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前用户的角色（这里简化为从Session中获取）</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> httpRequest.getSession();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> UserManager.getUser((String) session.getAttribute(<span class="string">&quot;username&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求的URL</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestedURL</span> <span class="operator">=</span> httpRequest.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查用户是否具有访问该URL的权限</span></span><br><span class="line">        <span class="keyword">if</span> (hasPermission(user, requestedURL)) &#123;</span><br><span class="line">            <span class="comment">// 用户有权限，继续处理请求</span></span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用户无权限，返回权限拒绝错误页面或重定向到其他页面</span></span><br><span class="line">            httpResponse.sendRedirect(<span class="string">&quot;accessDenied.jsp&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasPermission</span><span class="params">(User user, String requestedURL)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里简单地判断用户是否为管理员（ADMIN），可以根据实际需求进行更复杂的权限检查</span></span><br><span class="line">        <span class="keyword">return</span> user != <span class="literal">null</span> &amp;&amp; user.getRoles().contains(<span class="string">&quot;ADMIN&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 销毁过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们创建了一个名为<code>AuthorizationFilter</code>的过滤器，它拦截所有URL。在<code>doFilter</code>方法中，我们获取当前用户的角色，并检查用户是否具有访问请求URL的权限。如果用户具有权限，继续处理请求；如果用户无权限，可以重定向到权限拒绝页面或其他页面。</p><p>最后，我们需要在<code>web.xml</code>中配置这个过滤器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>AuthorizationFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.example.AuthorizationFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置过滤器映射 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>AuthorizationFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!-- 拦截所有URL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 其他Servlet、Listener等的配置 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，<code>AuthorizationFilter</code>将会拦截所有URL，并进行权限访问控制。在实际应用中，权限检查可能更加复杂，可以根据实际需求定制更复杂的权限控制逻辑。</p><h5 id="2-使用过滤器实现表单验证"><a href="#2-使用过滤器实现表单验证" class="headerlink" title="2.使用过滤器实现表单验证"></a>2.使用过滤器实现表单验证</h5><p>首先，我们创建一个简单的表单验证器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormValidator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">validate</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 进行简单的表单验证，这里简化为用户名和密码非空验证</span></span><br><span class="line">        <span class="keyword">return</span> username != <span class="literal">null</span> &amp;&amp; !username.isEmpty() &amp;&amp;</span><br><span class="line">               password != <span class="literal">null</span> &amp;&amp; !password.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们创建一个过滤器来进行表单验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/processForm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormValidationFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 初始化过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 获取表单数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表单数据验证</span></span><br><span class="line">        <span class="keyword">if</span> (FormValidator.validate(username, password)) &#123;</span><br><span class="line">            <span class="comment">// 数据合法，继续处理请求</span></span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 数据不合法，返回错误页面或重定向到其他页面</span></span><br><span class="line">            <span class="type">HttpServletResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line">            httpResponse.sendRedirect(<span class="string">&quot;formError.jsp&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 销毁过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们创建了一个名为<code>FormValidationFilter</code>的过滤器，它拦截了处理表单提交的Servlet（假设为<code>processForm</code>）。在<code>doFilter</code>方法中，我们获取表单数据并通过<code>FormValidator</code>进行简单的验证。如果表单数据合法，继续处理请求；如果数据不合法，可以重定向到错误页面或其他页面。</p><p>最后，我们需要在<code>web.xml</code>中配置这个过滤器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FormValidationFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.example.FormValidationFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置过滤器映射 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FormValidationFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/processForm<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!-- 拦截处理表单的Servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 其他Servlet、Listener等的配置 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，<code>FormValidationFilter</code>将会拦截表单提交的请求，并进行表单验证。在实际应用中，表单验证的逻辑可能更加复杂，可以根据实际需求定制更复杂的验证逻辑。</p><h3 id="7-2-监听器"><a href="#7-2-监听器" class="headerlink" title="7.2 监听器"></a>7.2 监听器</h3><p><strong>监听器（Listener）</strong> 在Java Web应用程序中用于监听各种事件，从而实现对应事件的响应。监听器允许开发者在特定事件发生时执行自定义代码，而无需修改应用程序的核心逻辑。Java Web中有多种监听器，分为三类：Servlet监听器、上下文监听器和会话监听器。</p><h4 id="1-Servlet监听器"><a href="#1-Servlet监听器" class="headerlink" title="1. Servlet监听器"></a>1. Servlet监听器</h4><p>Servlet监听器用于监听与Servlet相关的事件，主要有以下三种监听器：</p><ul><li><strong>ServletRequestListener</strong>：用于监听请求的创建和销毁事件。</li><li><strong>ServletRequestAttributeListener</strong>：用于监听请求属性变化的事件。</li><li><strong>HttpSessionListener</strong>：用于监听会话的创建和销毁事件。</li></ul><h4 id="2-上下文监听器"><a href="#2-上下文监听器" class="headerlink" title="2. 上下文监听器"></a>2. 上下文监听器</h4><p>上下文监听器用于监听Web应用上下文（ServletContext）的创建和销毁事件，主要有以下两种监听器：</p><ul><li><strong>ServletContextListener</strong>：用于监听Web应用的初始化和销毁事件。</li><li><strong>ServletContextAttributeListener</strong>：用于监听Web应用上下文属性变化的事件。</li></ul><h4 id="3-会话监听器"><a href="#3-会话监听器" class="headerlink" title="3. 会话监听器"></a>3. 会话监听器</h4><p>会话监听器用于监听会话（Session）的创建和销毁事件，主要有以下两种监听器：</p><ul><li><strong>HttpSessionListener</strong>：用于监听会话的创建和销毁事件。</li><li><strong>HttpSessionAttributeListener</strong>：用于监听会话属性变化的事件。</li></ul><h4 id="4-示例"><a href="#4-示例" class="headerlink" title="4.示例"></a>4.示例</h4><h5 id="1-JavaWeb状态监听器和属性监听器"><a href="#1-JavaWeb状态监听器和属性监听器" class="headerlink" title="1.JavaWeb状态监听器和属性监听器"></a>1.JavaWeb状态监听器和属性监听器</h5><p>首先，我们创建一个简单的JavaWeb应用，其中包含一个Servlet和一个JSP页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/CounterServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> (Integer) session.getAttribute(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        session.setAttribute(<span class="string">&quot;count&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        out.println(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Counter Servlet&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;h2&gt;Visit count: &quot;</span> + count + <span class="string">&quot;&lt;/h2&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">htmlCopy code&lt;!-- counter.jsp --&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Counter JSP&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h2&gt;Visit <span class="title function_">count</span> <span class="params">(from JSP)</span>: $&#123;sessionScope.count&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>接下来，我们创建一个会话监听器和一个属性监听器来监听会话的创建和属性变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionListener</span> <span class="keyword">implements</span> <span class="title class_">HttpSessionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionCreated</span><span class="params">(HttpSessionEvent se)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Session created: &quot;</span> + se.getSession().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Session destroyed: &quot;</span> + se.getSession().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">javaCopy codeimport javax.servlet.ServletContextAttributeEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextAttributeListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AttributeListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextAttributeListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeAdded</span><span class="params">(ServletContextAttributeEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Attribute added: &quot;</span> + event.getName() + <span class="string">&quot; = &quot;</span> + event.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeRemoved</span><span class="params">(ServletContextAttributeEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Attribute removed: &quot;</span> + event.getName() + <span class="string">&quot; = &quot;</span> + event.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeReplaced</span><span class="params">(ServletContextAttributeEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Attribute replaced: &quot;</span> + event.getName() + <span class="string">&quot; = &quot;</span> + event.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上示例中，我们使用了注解 <code>@WebListener</code> 来声明监听器。<code>SessionListener</code> 监听会话的创建和销毁事件，而 <code>AttributeListener</code> 监听了上下文属性的添加、删除和替换事件。</p><p>在Web应用中，当会话被创建时，会调用 <code>SessionListener</code> 中的 <code>sessionCreated</code> 方法，会输出 “Session created: …”。当会话被销毁时，会调用 <code>sessionDestroyed</code> 方法，会输出 “Session destroyed: …”。</p><p>在 <code>CounterServlet</code> 中，每次访问增加访问计数，将计数保存在会话属性中。 <code>AttributeListener</code> 监听会话属性的变化，当会话属性变化时，会输出相应的信息。</p><p>要使用以上示例，将 <code>CounterServlet</code> 和 <code>counter.jsp</code> 放在Web应用的 <code>WEB-INF</code> 目录下，将 <code>SessionListener</code> 和 <code>AttributeListener</code> 放在合适的包中，并确保已在 <code>web.xml</code> 中注册 Servlet、JSP 页面和监听器。</p><h5 id="2-利用HttpSessionListener统计在线人数"><a href="#2-利用HttpSessionListener统计在线人数" class="headerlink" title="2.利用HttpSessionListener统计在线人数"></a>2.利用HttpSessionListener统计在线人数</h5><p>在这个例子中，我们将利用该监听器实时统计在线用户的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnlineUserCounter</span> <span class="keyword">implements</span> <span class="title class_">HttpSessionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">onlineUsersCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionCreated</span><span class="params">(HttpSessionEvent se)</span> &#123;</span><br><span class="line">        onlineUsersCount++;</span><br><span class="line">        System.out.println(<span class="string">&quot;Session created. Online users count: &quot;</span> + onlineUsersCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (onlineUsersCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            onlineUsersCount--;</span><br><span class="line">            System.out.println(<span class="string">&quot;Session destroyed. Online users count: &quot;</span> + onlineUsersCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getOnlineUsersCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> onlineUsersCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们创建了一个名为 <code>OnlineUserCounter</code> 的 <code>HttpSessionListener</code>，用于统计在线用户数量。每当会话被创建或销毁时，相关事件会触发，增加或减少在线用户的计数。</p><p>要在Web应用中使用这个监听器，需要将它放在合适的包中，确保已经在 <code>web.xml</code> 中进行注册。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置监听器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.example.OnlineUserCounter<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 其他Servlet、JSP配置 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在，我们可以通过调用 <code>OnlineUserCounter.getOnlineUsersCount()</code> 来获取当前在线用户的数量。这个值可以在需要展示在线用户数的地方使用，比如在管理员面板或首页。</p><h2 id="八-MVC"><a href="#八-MVC" class="headerlink" title="八. MVC"></a>八. MVC</h2><p>MVC（Model-View-Controller）是一种软件设计模式，用于组织代码和实现用户界面与业务逻辑的分离。</p><h3 id="8-1-简介"><a href="#8-1-简介" class="headerlink" title="8.1 简介"></a>8.1 简介</h3><p>MVC模式通过将应用程序分为三个主要组件来实现代码的分离和组织：</p><ul><li><strong>Model（模型）</strong>：负责处理应用程序的数据和业务逻辑。模型通常包含应用程序的核心数据结构、数据库连接、数据存取、业务规则等。它不直接处理用户界面或用户输入。</li><li><strong>View（视图）</strong>：负责向用户展示数据，并根据模型的状态进行相应的更新。视图可以是任何形式的输出，如图形界面、控制台、网页等。</li><li><strong>Controller（控制器）</strong>：充当模型和视图之间的中介，处理用户输入并根据输入更新模型和视图。它接受用户输入，调用模型更新数据，然后通知视图更新以反映新的数据。</li></ul><p>MVC模式的目标是通过分离关注点，提高代码的可维护性、可扩展性和重用性。它使开发人员能够更容易地管理和维护应用程序的不同方面，而不会影响其他部分的功能。</p><h3 id="8-2-基于mvc设计理念的JavaWeb代码组织结构"><a href="#8-2-基于mvc设计理念的JavaWeb代码组织结构" class="headerlink" title="8.2 基于mvc设计理念的JavaWeb代码组织结构"></a>8.2 基于mvc设计理念的JavaWeb代码组织结构</h3><h4 id="1-Model（模型）"><a href="#1-Model（模型）" class="headerlink" title="1. Model（模型）"></a>1. <strong>Model（模型）</strong></h4><ul><li><strong>实体类（Entity Classes）</strong>：表示业务领域的对象，包括数据结构、业务逻辑等。这些类通常对应数据库中的表或业务实体。</li><li><strong>数据访问层（Data Access Layer）</strong>：负责与数据库交互，包括数据存取、数据库连接、ORM（Object-Relational Mapping）框架等。</li></ul><h4 id="2-View（视图）"><a href="#2-View（视图）" class="headerlink" title="2. View（视图）"></a>2. <strong>View（视图）</strong></h4><ul><li><strong>JSP页面或模板（JSP Pages or Templates）</strong>：负责展示用户界面，通常使用JSP页面或模板引擎（如Thymeleaf、FreeMarker）。</li><li><strong>HTML、CSS、JavaScript文件（HTML, CSS, JavaScript Files）</strong>：用于前端展示和交互，实现用户界面。</li></ul><h4 id="3-Controller（控制器）"><a href="#3-Controller（控制器）" class="headerlink" title="3. Controller（控制器）"></a>3. <strong>Controller（控制器）</strong></h4><ul><li><strong>Servlets or Controllers</strong>：负责接收用户请求、处理业务逻辑、调用模型和视图，控制应用程序的流程。</li></ul><h4 id="4-其他组件"><a href="#4-其他组件" class="headerlink" title="4. 其他组件"></a>4. <strong>其他组件</strong></h4><ul><li><strong>Service层（Service Layer）</strong>：包含业务逻辑，用于处理业务规则、算法等，协调多个模型之间的操作。</li><li><strong>DAO（Data Access Object）接口</strong>：定义数据访问的标准接口，用于隔离数据访问层的具体实现。</li><li><strong>工具类（Utility Classes）</strong>：包含通用的功能或工具方法，用于辅助开发，例如日期处理、加密、文件操作等。</li></ul><h4 id="5-示例目录结构"><a href="#5-示例目录结构" class="headerlink" title="5.示例目录结构"></a>5.示例目录结构</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">luaCopy code|<span class="comment">-- src</span></span><br><span class="line">|   |<span class="comment">-- main</span></span><br><span class="line">|       |<span class="comment">-- java</span></span><br><span class="line">|           |<span class="comment">-- com</span></span><br><span class="line">|               |<span class="comment">-- example</span></span><br><span class="line">|                   |<span class="comment">-- model</span></span><br><span class="line">|                       |<span class="comment">-- Entity1.java</span></span><br><span class="line">|                       |<span class="comment">-- Entity2.java</span></span><br><span class="line">|                   |<span class="comment">-- dao</span></span><br><span class="line">|                       |<span class="comment">-- Entity1DAO.java</span></span><br><span class="line">|                       |<span class="comment">-- Entity2DAO.java</span></span><br><span class="line">|                   |<span class="comment">-- service</span></span><br><span class="line">|                       |<span class="comment">-- Entity1Service.java</span></span><br><span class="line">|                       |<span class="comment">-- Entity2Service.java</span></span><br><span class="line">|                   |<span class="comment">-- controller</span></span><br><span class="line">|                       |<span class="comment">-- Entity1Controller.java</span></span><br><span class="line">|                       |<span class="comment">-- Entity2Controller.java</span></span><br><span class="line">|       |<span class="comment">-- webapp</span></span><br><span class="line">|           |<span class="comment">-- WEB-INF</span></span><br><span class="line">|               |<span class="comment">-- views</span></span><br><span class="line">|                   |<span class="comment">-- entity1.jsp</span></span><br><span class="line">|                   |<span class="comment">-- entity2.jsp</span></span><br><span class="line">|               |<span class="comment">-- web.xml</span></span><br></pre></td></tr></table></figure><h3 id="8-3-JavaBean"><a href="#8-3-JavaBean" class="headerlink" title="8.3 JavaBean"></a>8.3 JavaBean</h3><h4 id="8-3-1-简介"><a href="#8-3-1-简介" class="headerlink" title="8.3.1 简介"></a>8.3.1 简介</h4><p>JavaBean是一种符合特定编程规范的Java类，核心是命名属性。它是一种可重用组件的概念，旨在简化Java应用程序的开发。JavaBean是一种特定的Java类，其对象可以在Java编程环境中重用，并且可以通过图形界面构建工具（如IDE）进行可视化拖放操作。</p><p>以下是JavaBean的一些特征和规范：</p><ol><li><strong>命名规范</strong>：<ul><li>类名以大写字母开头，采用驼峰命名规范（首字母小写，后续单词首字母大写）。</li><li>必须具有一个无参的构造方法。</li></ul></li><li><strong>属性</strong>：<ul><li>通过getter和setter方法对属性进行访问和修改。Getter方法用于获取属性值，Setter方法用于设置属性值。</li></ul></li><li><strong>事件支持</strong>：<ul><li>可以通过事件机制通知其他对象发生的特定事件。</li></ul></li><li><strong>序列化支持</strong>：<ul><li>可以将JavaBean序列化为字节流，以便于存储或传输。</li></ul></li><li><strong>自省（Introspection）</strong>：<ul><li>JavaBean可以通过自省机制获取其属性、事件和方法的信息。</li></ul></li></ol><p>JavaBean的设计目的是为了促进Java程序的重用和可视化编程，它可以在图形界面设计工具中进行可视化操作，便于快速开发应用程序。JavaBean的概念和规范在Java开发中广泛应用，尤其在GUI编程、Web开发、框架开发等领域。</p><h4 id="8-3-2-命名属性的特殊情况"><a href="#8-3-2-命名属性的特殊情况" class="headerlink" title="8.3.2 命名属性的特殊情况"></a>8.3.2 命名属性的特殊情况</h4><ul><li>1.命名属性的惰性计算</li><li>2.合成属性</li></ul><h4 id="8-3-3-分类"><a href="#8-3-3-分类" class="headerlink" title="8.3.3 分类"></a>8.3.3 分类</h4><ul><li>1.FromBean</li><li>2.EntityBean</li></ul><h3 id="8-4-JSP内置对象"><a href="#8-4-JSP内置对象" class="headerlink" title="8.4 JSP内置对象"></a>8.4 JSP内置对象</h3><p>在JavaServer Pages（JSP）中，有一些内置对象，它们是Servlet容器自动创建和提供的，可以在JSP页面中直接使用。这些内置对象代表了不同的作用域和信息，方便开发者在JSP页面中访问请求、会话、上下文等数据。</p><p>以下是JSP中常用的内置对象：</p><ol><li><strong>request</strong>:<ul><li>代表HTTP请求，包括请求头、请求参数、请求方法等信息。可以通过该对象获取HTTP请求的所有信息。</li></ul></li><li><strong>response</strong>:<ul><li>代表HTTP响应，用于向客户端发送响应内容。可以通过该对象设置响应头、写入响应内容等。</li></ul></li><li><strong>out</strong>:<ul><li>用于输出内容到客户端。是一个PrintWriter对象，可以使用<code>out.print()</code>、<code>out.println()</code>等方法输出内容。</li></ul></li><li><strong>session</strong>:<ul><li>代表用户会话，可用于存储和检索特定用户会话的信息，以实现用户间的数据共享。</li></ul></li><li><strong>application</strong>:<ul><li>代表整个Web应用的上下文，可以用于在不同用户间共享数据。存储在application对象中的数据在整个应用程序内可见。</li></ul></li><li><strong>page</strong>:<ul><li>代表当前JSP页面的Servlet实例。可以用于调用自身的方法或设置属性。</li></ul></li><li><strong>config</strong>:<ul><li>代表当前JSP页面的Servlet配置信息，包括初始化参数等。</li></ul></li><li><strong>exception</strong>:<ul><li>代表在JSP页面中产生的异常，可以通过该对象获取异常信息。</li></ul></li><li><strong>pageContext</strong>:<ul><li>代表JSP页面的上下文，包含对其他所有内置对象的引用。可以用于访问页面范围、请求范围、会话范围和应用程序范围的属性。</li></ul></li></ol><p>这些内置对象使得在JSP页面中能够方便地访问到HTTP请求、会话、应用程序等信息，同时输出内容到客户端。可以使用这些内置对象来构建动态Web页面。</p><h3 id="8-5-EL"><a href="#8-5-EL" class="headerlink" title="8.5 EL"></a>8.5 EL</h3><p>EL（Expression Language，表达式语言）是一种用于在JSP、JSF、Java EE等Java相关技术中嵌入动态内容的简洁表达式语言。EL允许在JSP页面和其他Java EE技术中嵌入和评估表达式，以便访问数据、执行操作等。EL最初由JavaServer Faces（JSF）引入，现已成为Java EE的标准组件。</p><p>以下是EL的一些主要特点和功能：</p><ol><li><strong>简单表达式</strong>：<ul><li>EL提供了一种简洁的表达式语法，允许开发者直接嵌入到JSP页面或其他Java EE技术中。表达式使用<code>$&#123;&#125;</code>语法。</li></ul></li><li><strong>访问作用域对象</strong>：<ul><li>EL允许访问页面作用域（page）、请求作用域（request）、会话作用域（session）和应用程序作用域（application）中的属性。</li></ul></li><li><strong>访问JavaBean属性</strong>：<ul><li>可以直接访问JavaBean的属性和方法，而无需编写Java代码。例如<code>$&#123;user.name&#125;</code>可以获取JavaBean中的name属性。</li></ul></li><li><strong>运算符和函数</strong>：<ul><li>EL支持多种运算符（算术、逻辑、关系等）和内置函数，可用于执行各种操作，如计算、比较、字符串处理等。</li></ul></li><li><strong>集合和数组访问</strong>：<ul><li>可以通过EL访问集合和数组的元素，以及调用相应的方法。</li></ul></li><li><strong>条件运算和循环控制</strong>：<ul><li>支持条件运算（如三元运算符）和循环控制（如forEach）。</li></ul></li><li><strong>引入其他资源</strong>：<ul><li>可以使用EL引入其他资源，如外部属性文件、环境变量等。</li></ul></li></ol><p>EL极大地简化了JSP页面和其他Java EE技术中的数据访问和操作，使开发更简单、可读性更强、维护更方便。 EL也是JavaServer Faces（JSF）和其他Java EE技术的基础，为Java EE应用程序的开发提供了便利。</p><h2 id="九-数据库设计及实现"><a href="#九-数据库设计及实现" class="headerlink" title="九. 数据库设计及实现"></a>九. 数据库设计及实现</h2><p>数据库设计及实现是指在软件开发过程中设计和创建数据库的结构、表、关系、约束和索引，以及实现数据库的功能和存储数据。这是一个关键的步骤，影响到软件系统的性能、可扩展性、安全性等方面。</p><p>下面是一个简单的数据库设计和实现的步骤：</p><p> <strong>1.需求分析和规划</strong></p><p>在开始设计数据库之前，首先要明确需求。这包括了解系统需要存储哪些数据、数据之间的关系、数据的类型和范围、查询需求等。然后制定数据库设计的计划和时间表。</p><p><strong>2. 概念设计</strong></p><p>在概念设计阶段，需要创建概念模型，包括实体-关系图（ERD）或UML类图。这里定义了系统中的实体、属性和它们之间的关系。</p><p><strong>3. 逻辑设计</strong></p><p>在逻辑设计阶段，将概念模型转换为逻辑模型，包括确定关系型数据库的表、字段、主键、外键等。选择合适的数据类型、约束和索引。</p><p><strong>4. 范式设计</strong></p><p>应用范式来确保数据库的设计满足特定的范式要求。常用的范式有第一范式（1NF）、第二范式（2NF）、第三范式（3NF）等，可以保证数据库的结构清晰、数据一致。</p><p><strong>5. 物理设计</strong></p><p>在物理设计阶段，确定数据库存储方案，包括选择适当的存储引擎、分区策略、备份策略等，以保证数据库的性能、可用性和安全性。</p><p><strong>6. 实现数据库</strong></p><p>基于逻辑设计和物理设计的结果，开始实现数据库结构、表、索引、视图、存储过程、触发器等。</p><p><strong>7. 测试</strong></p><p>对数据库进行测试，包括功能测试、性能测试、安全性测试等，确保数据库设计的正确性和稳定性。</p><p><strong>8. 优化和调整</strong></p><p>根据测试结果，进行必要的优化和调整，包括优化查询、调整索引、优化存储过程等，以提高数据库的性能和效率。</p><p><strong>9. 部署和维护</strong></p><p>将设计好的数据库部署到生产环境，进行必要的数据迁移、备份、监控和维护工作，确保数据库的正常运行和数据的安全性。</p><p><strong>10. 监控和优化</strong></p><p>定期监控数据库的性能，进行数据库的优化和调整，以保持数据库的高效性。</p><p>以上步骤可以根据具体的项目需求进行调整和扩展，数据库设计和实现是一个迭代的过程，需要不断调整和改进以满足项目的需求。</p><h2 id="十-MySQL事务机制和JDBC"><a href="#十-MySQL事务机制和JDBC" class="headerlink" title="十. MySQL事务机制和JDBC"></a>十. MySQL事务机制和JDBC</h2><p><img src="/.assets/image-20230927201641140.png" alt="image-20230927201641140"></p><h3 id="10-1-事务机制"><a href="#10-1-事务机制" class="headerlink" title="10.1 事务机制"></a>10.1 事务机制</h3><p>MySQL事务机制是指MySQL数据库管理系统如何处理事务，确保数据的一致性、隔离性、持久性和原子性。事务是一系列操作组成的逻辑工作单元，要么全部执行成功，要么全部失败，不允许部分执行。</p><h4 id="10-1-1-遵循ACID属性"><a href="#10-1-1-遵循ACID属性" class="headerlink" title="10.1.1 遵循ACID属性"></a>10.1.1 遵循ACID属性</h4><p>MySQL遵循ACID属性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。</p><ol><li><strong>原子性（Atomicity）</strong></li></ol><p>原子性指一个事务中的所有操作要么全部执行成功，要么全部失败。MySQL通过事务日志（redo log）确保事务的原子性。</p><ol start="2"><li><strong>一致性（Consistency）</strong></li></ol><p>一致性指事务的执行保持系统从一个一致性状态到另一个一致性状态。事务执行过程中，数据库约束不会被破坏。MySQL通过事务日志、事务日志的同步刷盘等方式实现一致性。</p><ol start="3"><li><strong>隔离性（Isolation）</strong></li></ol><p>隔离性指多个事务同时执行时，每个事务的操作都不会对其他事务产生影响。MySQL提供不同的事务隔离级别来实现隔离性，包括读未提交（Read Uncommitted）、读提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。</p><ol start="4"><li><strong>持久性（Durability）</strong></li></ol><p>持久性指事务一旦提交，其结果将永久保存在数据库中，并对后续的事务可见。MySQL通过事务日志确保事务的持久性。</p><h4 id="10-1-2-MySQL事务隔离级别"><a href="#10-1-2-MySQL事务隔离级别" class="headerlink" title="10.1.2 MySQL事务隔离级别"></a><strong>10.1.2 MySQL事务隔离级别</strong></h4><p>MySQL定义了四种事务隔离级别，可以通过<code>SET TRANSACTION ISOLATION LEVEL</code>语句进行设置：</p><ul><li><strong>READ UNCOMMITTED</strong>：允许读取尚未提交的数据变更，最低的隔离级别，可能导致脏读、不可重复读和幻读的问题。</li><li><strong>READ COMMITTED</strong>：只能读取已经提交的数据，可以避免脏读，但仍可能发生不可重复读和幻读。</li><li><strong>REPEATABLE READ</strong>：确保同一事务中多次读取同样的数据时，结果一致，可以避免脏读和不可重复读，但仍可能发生幻读。</li><li><strong>SERIALIZABLE</strong>：最高的隔离级别，确保事务之间的完全隔离，避免脏读、不可重复读和幻读，但会降低并发性能。</li></ul><h4 id="10-1-3-MySQL事务控制语句"><a href="#10-1-3-MySQL事务控制语句" class="headerlink" title="10.1.3 MySQL事务控制语句"></a>10.1.3 MySQL事务控制语句</h4><p>MySQL提供以下常用的事务控制语句：</p><ul><li><strong>START TRANSACTION</strong>：开始事务。</li><li><strong>COMMIT</strong>：提交事务，将事务中的所有操作永久保存到数据库。</li><li><strong>ROLLBACK</strong>：回滚事务，取消事务中的所有操作。</li><li><strong>SAVEPOINT</strong>：设置事务的保存点，可以在事务中部分回滚到指定的保存点。</li><li><strong>SET TRANSACTION</strong>：设置事务属性，如隔离级别。</li></ul><p>这些语句可以帮助控制事务的开始、提交、回滚和隔离级别等属性。</p><h3 id="10-2-JDBC"><a href="#10-2-JDBC" class="headerlink" title="10.2 JDBC"></a>10.2 JDBC</h3><h4 id="10-2-1-简介"><a href="#10-2-1-简介" class="headerlink" title="10.2.1 简介"></a>10.2.1 简介</h4><p>DBC（Java Database Connectivity）是Java编程语言用于与数据库进行连接和交互的标准API。JDBC允许Java应用程序与各种数据库进行通信，执行SQL语句，处理结果集等，提供了一种统一的方式来访问不同数据库的数据。</p><p>以下是JDBC的一些主要特点和功能：</p><ol><li><strong>数据库连接</strong>：<ul><li>JDBC允许Java应用程序通过连接字符串、用户名和密码建立与数据库的连接，从而进行数据交互。</li></ul></li><li><strong>SQL执行</strong>：<ul><li>可以通过JDBC执行SQL语句（如SELECT、INSERT、UPDATE、DELETE）并获取执行结果。</li></ul></li><li><strong>事务管理</strong>：<ul><li>JDBC允许应用程序通过事务管理功能来控制数据库事务的开始、提交、回滚。</li></ul></li><li><strong>错误处理</strong>：<ul><li>JDBC提供了一套错误处理机制，可以捕获和处理数据库操作中可能发生的错误。</li></ul></li><li><strong>PreparedStatement和CallableStatement</strong>：<ul><li>提供了PreparedStatement和CallableStatement，可以通过参数化的方式执行SQL语句，防止SQL注入攻击。</li></ul></li><li><strong>元数据访问</strong>：<ul><li>可以通过JDBC访问数据库的元数据，获取数据库、表、字段等信息。</li></ul></li><li><strong>批处理</strong>：<ul><li>允许将多个SQL语句一起发送到数据库，提高数据库操作的效率。</li></ul></li><li><strong>结果集处理</strong>：<ul><li>JDBC提供了ResultSet接口，允许Java程序对查询结果进行处理，获取和遍历查询结果。</li></ul></li></ol><p>JDBC采用了面向对象的编程方式，通过Java类和接口封装了对数据库的访问。在使用JDBC时，需要先加载数据库驱动程序，然后建立与数据库的连接，创建Statement或PreparedStatement对象，执行SQL语句并处理结果。</p><h4 id="10-2-2-连接步骤"><a href="#10-2-2-连接步骤" class="headerlink" title="10.2.2 连接步骤"></a>10.2.2 连接步骤</h4><p><img src="/.assets/image-20230927201712012.png" alt="image-20230927201712012"></p><p>典型的JDBC使用步骤包括：</p><ol><li><strong>加载驱动程序</strong>：使用<code>Class.forName()</code>方法加载特定数据库的JDBC驱动程序。</li><li><strong>建立连接</strong>：使用<code>DriverManager.getConnection()</code>方法建立与数据库的连接，返回一个Connection对象。</li><li><strong>创建Statement或PreparedStatement</strong>：使用Connection对象的<code>createStatement()</code>或<code>prepareStatement()</code>方法创建Statement或PreparedStatement对象。</li><li><strong>执行SQL语句</strong>：通过Statement或PreparedStatement对象执行SQL语句，获取执行结果。</li><li><strong>处理结果</strong>：根据需要处理SQL执行的结果，如读取查询结果、处理更新记录等。</li><li><strong>关闭连接</strong>：使用Connection对象的<code>close()</code>方法关闭数据库连接。</li></ol><p>以下是一个简单的Java程序演示如何通过JDBC连接MySQL数据库并执行一条简单的SQL查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo</span> &#123;</span><br><span class="line">    <span class="comment">// JDBC URL、用户名和密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JDBC_URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/your_database&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;your_username&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;your_password&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 加载驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 建立连接</span></span><br><span class="line">            connection = DriverManager.getConnection(JDBC_URL, USER, PASSWORD);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 创建SQL语句</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE name = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 使用con对象预处理SQL语句</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5. 设置参数</span></span><br><span class="line">preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;John&quot;</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 执行SQL查询</span></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span>preparedStatement.executeQuery();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 处理结果集</span></span><br><span class="line">            <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                <span class="comment">// 获取数据并处理</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;ID: &quot;</span> + id + <span class="string">&quot;, Name: &quot;</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 8. 关闭连接</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (resultSet != <span class="literal">null</span>) resultSet.close();</span><br><span class="line">                <span class="keyword">if</span> (statement != <span class="literal">null</span>) statement.close();</span><br><span class="line">                <span class="keyword">if</span> (connection != <span class="literal">null</span>) connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际项目中，推荐使用try-with-resources语句来确保资源的自动关闭，不需要手动关闭连接、Statement和ResultSet。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(JDBC_URL, USER, PASSWORD);</span><br><span class="line">     <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">     <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理结果集</span></span><br><span class="line">    <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">        <span class="comment">// 获取数据并处理</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ID: &quot;</span> + id + <span class="string">&quot;, Name: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-3-多个DAO公用同一个数据库连接对象的解决办法"><a href="#10-2-3-多个DAO公用同一个数据库连接对象的解决办法" class="headerlink" title="10.2.3 多个DAO公用同一个数据库连接对象的解决办法"></a>10.2.3 多个DAO公用同一个数据库连接对象的解决办法</h4><p>在Java应用程序中，多个DAO共享同一个数据库连接对象可能会导致并发问题和资源泄漏。</p><p>为了解决这个问题，你可以使用一种设计模式称为“数据库连接池”，它允许多个DAO共享一组数据库连接，并且能够有效地管理这些连接。</p><p>以下是一种常见的使用数据库连接池的解决方案：</p><h5 id="1-使用连接池管理数据库连接"><a href="#1-使用连接池管理数据库连接" class="headerlink" title="1.使用连接池管理数据库连接"></a>1.使用连接池管理数据库连接</h5><ul><li><strong>引入连接池库</strong>： 选择一个合适的数据库连接池实现，比如常用的Apache Commons DBCP、HikariCP、C3P0等。将连接池库的相关jar包引入项目中。</li><li><strong>配置连接池</strong>： 配置连接池的属性，例如数据库URL、用户名、密码、最大连接数、最小空闲连接数等。</li><li><strong>初始化连接池</strong>： 在应用程序启动时，初始化连接池并创建一组数据库连接。</li><li><strong>从连接池获取连接</strong>： DAO需要使用数据库连接时，从连接池获取一个连接。</li><li><strong>执行数据库操作</strong>： 使用获取的连接执行数据库操作。</li><li><strong>释放连接</strong>： 操作完成后，将连接释放回连接池，而不是关闭连接。</li></ul><p>假设你选择了HikariCP作为连接池，以下是一个简单示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.zaxxer.hikari.HikariConfig;</span><br><span class="line"><span class="keyword">import</span> com.zaxxer.hikari.HikariDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionPoolManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HikariDataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池属性</span></span><br><span class="line">        <span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">        config.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>);</span><br><span class="line">        config.setUsername(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        config.setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        config.setMaximumPoolSize(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化连接池</span></span><br><span class="line">        dataSource = <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在DAO中使用这个连接池来获取数据库连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDAO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveData</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionPoolManager.getConnection()) &#123;</span><br><span class="line">            <span class="comment">// 使用连接执行数据库操作</span></span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;INSERT INTO table_name (column_name) VALUES (?)&quot;</span>);</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>, data);</span><br><span class="line">            preparedStatement.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，不同的DAO可以共享同一个连接池，避免了多个DAO共用同一个数据库连接对象的问题，也能更有效地管理数据库连接。</p><p><img src="/.assets/image-20230927203257561.png" alt="image-20230927203257561"></p><p><img src="/.assets/image-20230927203319170.png" alt="image-20230927203319170"></p><p><img src="/.assets/image-20230927203332561.png" alt="image-20230927203332561"></p><h4 id="10-2-4-ThreadLocal工具类"><a href="#10-2-4-ThreadLocal工具类" class="headerlink" title="10.2.4 ThreadLocal工具类"></a>10.2.4 ThreadLocal工具类</h4><p><code>ThreadLocal</code> 是 Java 中的一个工具类，用于提供线程本地变量。每个线程都可以独立访问其对应的线程本地变量，线程间互不影响。通常情况下，通过 <code>ThreadLocal</code> 创建的变量对于每个线程来说是独立的，线程间不共享。</p><h5 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1.使用场景"></a>1.使用场景</h5><p><code>ThreadLocal</code> 主要用于解决多线程并发访问共享变量时的线程安全问题，尤其是在Web开发中，常用于在多线程环境下存储和管理用户会话、数据库连接等资源，确保线程间数据隔离，提高程序的并发性能。</p><h5 id="2基本用法"><a href="#2基本用法" class="headerlink" title="2基本用法"></a>2基本用法</h5><ul><li><p><strong>创建ThreadLocal变量</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="string">&quot;Initial Value&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>设置ThreadLocal变量</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(<span class="string">&quot;Value&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>获取ThreadLocal变量</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get();</span><br></pre></td></tr></table></figure></li><li><p><strong>移除ThreadLocal变量</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.remove();</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="string">&quot;Initial Value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置ThreadLocal变量</span></span><br><span class="line">        threadLocal.set(<span class="string">&quot;Value for Thread 1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取ThreadLocal变量</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value1</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1: &quot;</span> + value1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置ThreadLocal变量</span></span><br><span class="line">            threadLocal.set(<span class="string">&quot;New Value for Thread 1&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取更新后的ThreadLocal变量</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value2</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 Updated Value: &quot;</span> + value2);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取ThreadLocal变量</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value1</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 2: &quot;</span> + value1);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们创建了一个 <code>ThreadLocal</code> 变量，然后在两个不同的线程中分别获取和设置该变量。每个线程都拥有独立的变量副本，彼此间互不影响。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/10/06/hello-world/"/>
      <url>/2023/10/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
